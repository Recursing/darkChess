{
  "version": 3,
  "file": "bundle.css",
  "sources": [
    "../../App.svelte",
    "../../WebRTCConnection.svelte"
  ],
  "sourcesContent": [
    "<script>\n  import { BoardState, getPieces, getPossibleMoves, makeMove } from \"./chess\";\n  import WebRTCConnection from \"./WebRTCConnection.svelte\";\n  export let myColor;\n  let boardState = new BoardState(myColor);\n  let myTurn = myColor === \"white\";\n  let sendObject;\n\n  function onMessage(message) {\n    console.log(\"Got message\");\n    console.log(message);\n    let [from, to] = message.detail;\n    let tr = function(n) {\n      return 63 - n;\n    };\n    boardState = makeMove(boardState, tr(from), tr(to));\n    selected = null;\n    destinations = [];\n    myTurn = true;\n  }\n  console.log(boardState);\n\n  $: squares = getPieces(boardState);\n  function getImage(square) {\n    let color = myColor;\n    if (square.color === \"opponent\") {\n      color = myColor === \"white\" ? \"black\" : \"white\";\n    }\n    return `./images/${color}/${square.name}.svg`;\n  }\n  function onClick(i) {\n    if (!myTurn) {\n      return;\n    }\n    if (selected != null && destinations.includes(i)) {\n      destinations = [];\n      console.log(\"making move!\");\n      boardState = makeMove(boardState, selected, i);\n      sendObject([selected, i]);\n      myTurn = false;\n      selected = null;\n      return;\n    }\n    if (squares[i].color !== \"mine\") {\n      selected = null;\n      destinations = [];\n      return;\n    }\n    selected = i;\n    destinations = getPossibleMoves(boardState, i);\n  }\n  let selected = null;\n  let destinations = [];\n  $: possibleDestinations = squares.flatMap((s, i) =>\n    getPossibleMoves(boardState, i)\n  );\n  $: unreachables = squares.map(\n    (s, i) => s.color !== \"mine\" && !possibleDestinations.includes(i)\n  );\n</script>\n\n<style>\n  #board {\n    max-width: 80vh;\n    margin-left: auto;\n    margin-right: auto;\n  }\n  .square {\n    width: calc(100% / 8);\n    float: left;\n    user-select: none;\n    height: 0;\n    padding-bottom: calc(100% / 8);\n  }\n  .dark {\n    background-color: #b58863;\n  }\n  .light {\n    background-color: #f0d9b5;\n  }\n  .selected {\n    box-shadow: 0px 0px 50px 20px rgba(20, 85, 30, 0.6) inset;\n    outline: 2px solid;\n    outline-color: rgba(0, 0, 0, 0.1);\n    outline-offset: -2px;\n  }\n  .unreachable {\n    background-color: #dcb;\n    width: 100%;\n    height: 0;\n    padding-bottom: 100%;\n  }\n\n  .move-dest {\n    box-shadow: 0px 0px 50px 6px rgba(20, 85, 30, 0.3) inset;\n  }\n  img {\n    width: 100%;\n    user-select: none;\n  }\n  h1,\n  p {\n    text-align: center;\n    font-family: -apple-system, BlinkMacSystemFont, \"Segoe UI\", Roboto,\n      Oxygen-Sans, Ubuntu, Cantarell, \"Helvetica Neue\", sans-serif;\n    color: #333;\n  }\n  p {\n    font-size: 1.4em;\n  }\n</style>\n\n<WebRTCConnection bind:sendObject on:onMessage={onMessage} />\n<h1>\n  {#if myTurn}Click a piece to play!{:else}Waiting for other player...{/if}\n</h1>\n<div id=\"board\">\n  {#each squares as square, i}\n    <div\n      class=\"square\"\n      class:dark={Math.floor((i * 9) / 8) % 2}\n      class:light={1 - (Math.floor((i * 9) / 8) % 2)}\n      class:selected={selected === i}\n      class:move-dest={destinations.includes(i)}\n      on:click={() => onClick(i)}>\n      {#if unreachables[i]}\n        <div class=\"unreachable\" />\n      {:else if square.color}\n        <img\n          src={getImage(square)}\n          alt={square.name}\n          draggable=\"false\"\n          ondragstart=\"return false;\" />\n      {/if}\n    </div>\n  {/each}\n  <p>\n    See rules on\n    <a href=\"https://en.wikipedia.org/wiki/Dark_chess\">wikipedia!</a>\n  </p>\n</div>\n",
    "<script>\n  import { onMount } from \"svelte\";\n  import { createEventDispatcher } from \"svelte\";\n\n  const dispatch = createEventDispatcher();\n\n  let connection = null;\n  let out_url = null;\n\n  export function sendObject(obj) {\n    connection.send(JSON.stringify(obj));\n  }\n\n  function connectToInitiator(pid) {\n    // Please self host your own signaling server,\n    // see https://github.com/peers/peerjs-server\n    const peer = new Peer();\n    peer.on(\"open\", () => {\n      console.log(\"Peer opened, connecting to:\", pid);\n      connection = peer.connect(pid);\n      connection.on(\"open\", () => {\n        connection.on(\"data\", data => {\n          console.log(\"got data:\", data);\n          dispatch(\"onMessage\", JSON.parse(data));\n        });\n      });\n    });\n    peer.on(\"error\", err => {\n      console.error(err);\n      alert(err);\n    });\n\n    peer.on(\"connection\", conn => {\n      console.log(\"CONNECTED!\");\n      console.log(conn);\n    });\n  }\n\n  function createInitiator() {\n    // Please self host your own signaling server\n    // see https://github.com/peers/peerjs-server\n    const peer = new Peer();\n    peer.on(\"open\", function(id) {\n      console.log(\"My peer ID is: \" + id);\n      out_url = location.href + \"#\" + peer.id;\n    });\n\n    peer.on(\"error\", err => {\n      console.error(err);\n      alert(err);\n    });\n\n    peer.on(\"connection\", conn => {\n      connection = conn;\n      console.log(\"CONNECTED! with connection:\");\n      console.log(conn);\n      conn.on(\"data\", data => {\n        console.log(\"got data:\", data);\n        dispatch(\"onMessage\", JSON.parse(data));\n      });\n      conn.on(\"close\", () => {\n        console.error(\"connection closed\");\n        alert(\"Connection closed!\");\n      });\n    });\n  }\n\n  onMount(async () => {\n    const pid = location.hash.slice(1);\n    if (pid) {\n      console.log(\"connecting to \" + pid);\n      connectToInitiator(pid);\n    } else {\n      console.log(\"creating initiator peer\");\n      createInitiator();\n    }\n  });\n</script>\n\n<style>\n  p,\n  a {\n    text-align: center;\n    font-family: -apple-system, BlinkMacSystemFont, \"Segoe UI\", Roboto,\n      Oxygen-Sans, Ubuntu, Cantarell, \"Helvetica Neue\", sans-serif;\n    color: #333;\n  }\n</style>\n\n{#if !connection}\n  <p>Establishing connection...</p>\n  {#if out_url}\n    <a\n      href={out_url}\n      on:click|preventDefault={() => navigator.clipboard\n          .writeText(out_url)\n          .then(() => alert('Link copied! Send it to opponent'))}>\n      {out_url}\n    </a>\n  {/if}\n{/if}\n"
  ],
  "names": [],
  "mappings": "AA8DE,MAAM,eAAC,CAAC,AACN,SAAS,CAAE,IAAI,CACf,WAAW,CAAE,IAAI,CACjB,YAAY,CAAE,IAAI,AACpB,CAAC,AACD,OAAO,eAAC,CAAC,AACP,KAAK,CAAE,KAAK,IAAI,CAAC,CAAC,CAAC,CAAC,CAAC,CACrB,KAAK,CAAE,IAAI,CACX,WAAW,CAAE,IAAI,CACjB,MAAM,CAAE,CAAC,CACT,cAAc,CAAE,KAAK,IAAI,CAAC,CAAC,CAAC,CAAC,CAAC,AAChC,CAAC,AACD,KAAK,eAAC,CAAC,AACL,gBAAgB,CAAE,OAAO,AAC3B,CAAC,AACD,MAAM,eAAC,CAAC,AACN,gBAAgB,CAAE,OAAO,AAC3B,CAAC,AACD,SAAS,eAAC,CAAC,AACT,UAAU,CAAE,GAAG,CAAC,GAAG,CAAC,IAAI,CAAC,IAAI,CAAC,KAAK,EAAE,CAAC,CAAC,EAAE,CAAC,CAAC,EAAE,CAAC,CAAC,GAAG,CAAC,CAAC,KAAK,CACzD,OAAO,CAAE,GAAG,CAAC,KAAK,CAClB,aAAa,CAAE,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,GAAG,CAAC,CACjC,cAAc,CAAE,IAAI,AACtB,CAAC,AACD,YAAY,eAAC,CAAC,AACZ,gBAAgB,CAAE,IAAI,CACtB,KAAK,CAAE,IAAI,CACX,MAAM,CAAE,CAAC,CACT,cAAc,CAAE,IAAI,AACtB,CAAC,AAED,UAAU,eAAC,CAAC,AACV,UAAU,CAAE,GAAG,CAAC,GAAG,CAAC,IAAI,CAAC,GAAG,CAAC,KAAK,EAAE,CAAC,CAAC,EAAE,CAAC,CAAC,EAAE,CAAC,CAAC,GAAG,CAAC,CAAC,KAAK,AAC1D,CAAC,AACD,GAAG,eAAC,CAAC,AACH,KAAK,CAAE,IAAI,CACX,WAAW,CAAE,IAAI,AACnB,CAAC,AACD,iBAAE,CACF,CAAC,eAAC,CAAC,AACD,UAAU,CAAE,MAAM,CAClB,WAAW,CAAE,aAAa,CAAC,CAAC,kBAAkB,CAAC,CAAC,UAAU,CAAC,CAAC,MAAM,CAAC;MACjE,WAAW,CAAC,CAAC,MAAM,CAAC,CAAC,SAAS,CAAC,CAAC,gBAAgB,CAAC,CAAC,UAAU,CAC9D,KAAK,CAAE,IAAI,AACb,CAAC,AACD,CAAC,eAAC,CAAC,AACD,SAAS,CAAE,KAAK,AAClB,CAAC;AC7BD,eAAC,CACD,CAAC,cAAC,CAAC,AACD,UAAU,CAAE,MAAM,CAClB,WAAW,CAAE,aAAa,CAAC,CAAC,kBAAkB,CAAC,CAAC,UAAU,CAAC,CAAC,MAAM,CAAC;MACjE,WAAW,CAAC,CAAC,MAAM,CAAC,CAAC,SAAS,CAAC,CAAC,gBAAgB,CAAC,CAAC,UAAU,CAC9D,KAAK,CAAE,IAAI,AACb,CAAC"
}